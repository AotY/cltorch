#include <string>

std::string THClSortUtils_getKernelTemplate() {
  // [[[cog
  // import stringify
  // stringify.write_kernel( "kernel", "THClSortUtils.cl" )
  // ]]]
  // generated using cog, from THClSortUtils.cl:
  const char * kernelSource =  
  "// from lib/THC/THCSortUtils.cuh:\n" 
  "\n" 
  "/*__device__*/ inline void swapVars_K({{K}} *p_t1, {{K}}*p_t2) {\n" 
  "  {{K}} tmp = *p_t1;\n" 
  "  *p_t1 = *p_t2;\n" 
  "  *p_t2 = tmp;\n" 
  "}\n" 
  "\n" 
  "/*__device__*/ inline void swapVars_V({{V}} *p_t1, {{V}}*p_t2) {\n" 
  "  {{V}} tmp = *p_t1;\n" 
  "  *p_t1 = *p_t2;\n" 
  "  *p_t2 = tmp;\n" 
  "}\n" 
  "\n" 
  "/*__device__*/ inline void swapVars_bool(bool *p_t1, bool *p_t2) {\n" 
  "  bool tmp = *p_t1;\n" 
  "  *p_t1 = *p_t2;\n" 
  "  *p_t2 = tmp;\n" 
  "}\n" 
  "\n" 
  "template <typename Comparator>\n" 
  "/*__device__*/ inline void bitonicSwap({{K}}* p_kA, V*p_vA, bool*p_validA,\n" 
  "                                   {{K}}* p_kB, V*p_vB, bool*p_validB,\n" 
  "                                   bool dir,\n" 
  "                                   const Comparator& comp) {\n" 
  "  // Invalid entries always sort to the end\n" 
  "  bool swap = (comp(kA, kB) && validA) || !validB;\n" 
  "  if (swap == dir) {\n" 
  "    swapVars_K(p_kA, p_kB);\n" 
  "    swapVars_V(p_vA, p_vB);\n" 
  "    swapVars_bool(p_validA, p_validB);\n" 
  "  }\n" 
  "};\n" 
  "\n" 
  "template <typename Comparator,\n" 
  "          typename {{IndexType}}, int Power2SortSize>\n" 
  "/*__device__*/ inline void bitonicSort({{K}} keys[Power2SortSize],\n" 
  "                                   {{V}} values[Power2SortSize],\n" 
  "                                   bool valid[Power2SortSize],\n" 
  "                                   const Comparator& comp) {\n" 
  "#pragma unroll\n" 
  "  for (unsigned int size = 2; size < Power2SortSize; size *= 2) {\n" 
  "    bool flag = ((get_local_id(0) & (size / 2)) != 0);\n" 
  "\n" 
  "#pragma unroll\n" 
  "    for (unsigned int stride = size / 2; stride > 0; stride /= 2) {\n" 
  "\n" 
  "      // Single warp per slice is completely synchronous\n" 
  "      if (Power2SortSize > 64) {\n" 
  "        barrier(CLK_LOCAL_MEM_FENCE);\n" 
  "      }\n" 
  "\n" 
  "      unsigned int pos = 2 * get_local_id(0) - (get_local_id(0) & (stride - 1));\n" 
  "      bitonicSwap<Comparator>(\n" 
  "        &keys[pos], &values[pos], &valid[pos],\n" 
  "        &keys[pos + stride], &values[pos + stride], &valid[pos + stride],\n" 
  "        flag, comp);\n" 
  "    }\n" 
  "  }\n" 
  "\n" 
  "#pragma unroll\n" 
  "  for (unsigned int stride = Power2SortSize / 2; stride > 0; stride /= 2) {\n" 
  "    // Single warp per slice is completely synchronous\n" 
  "    if (Power2SortSize > 64) {\n" 
  "      barrier(CLK_LOCAL_MEM_FENCE);\n" 
  "    }\n" 
  "\n" 
  "    unsigned int pos = 2 * get_local_id(0) - (get_local_id(0) & (stride - 1));\n" 
  "    bitonicSwap<Comparator>(\n" 
  "      &keys[pos], &values[pos], &valid[pos],\n" 
  "      &keys[pos + stride], &values[pos + stride], &valid[pos + stride],\n" 
  "      false, comp);\n" 
  "  }\n" 
  "\n" 
  "  // Single warp per slice is completely synchronous\n" 
  "  if (Power2SortSize > 64) {\n" 
  "    barrier(CLK_LOCAL_MEM_FENCE);\n" 
  "  }\n" 
  "}\n" 
  "\n" 
  "// Sorts (key, value) pairs (in different tensors) in-place; i.e.,\n" 
  "// modifies the input `keys` and `values`\n" 
  "template <int KeyDims, int ValueDims,\n" 
  "          typename Comparator, typename {{IndexType}}, int Power2SortSize>\n" 
  "kernel void\n" 
  "bitonicSortKVInPlace(TensorInfo<{{IndexType}}> keys,\n" 
  "                     {{IndexType}} keySlices,\n" 
  "                     {{IndexType}} keySliceSize,\n" 
  "                     {{IndexType}} keySliceStride,\n" 
  "                     TensorInfo<{{IndexType}}> values,\n" 
  "                     {{IndexType}} valueSliceStride,\n" 
  "                     const Comparator& comp) {\n" 
  "  // Find the slice of the tensor that we are sorting\n" 
  "  const {{IndexType}} linearIndex = getLinearBlockId<{{IndexType}}>();\n" 
  "  // Tiling the slices could have us be out of bounds, if there are a\n" 
  "  // lot of slices to sort\n" 
  "  if (linearIndex >= keySlices) {\n" 
  "    return;\n" 
  "  }\n" 
  "\n" 
  "  local {{K}} sharedKeys[Power2SortSize];\n" 
  "  local {{V}} sharedValues[Power2SortSize];\n" 
  "  local bool sharedValid[Power2SortSize];\n" 
  "\n" 
  "  const {{IndexType}} keyStartOffset =\n" 
  "    IndexToOffset<{{IndexType}}, KeyDims>::get(linearIndex, keys);\n" 
  "  const {{IndexType}} valueStartOffset =\n" 
  "    IndexToOffset<{{IndexType}}, ValueDims>::get(linearIndex, values);\n" 
  "\n" 
  "  // If the sort size is 1, the data is already sorted\n" 
  "  if (Power2SortSize == 1) {\n" 
  "    return;\n" 
  "  } else {\n" 
  "    // Otherwise, each thread is responsible for loading and storing 2\n" 
  "    // elements. The sort size is guaranteed to be >= 2\n" 
  "    const int elem1 = get_local_id(0);\n" 
  "    const int elem2 = get_local_id(0) + (Power2SortSize / 2);\n" 
  "\n" 
  "    bool valid1 = (elem1 < keySliceSize);\n" 
  "    {{K}} k1 = valid1 ?\n" 
  "      keys.data[keyStartOffset + elem1 * keySliceStride] : ({{K}}) 0;\n" 
  "    {{V}} v1 = valid1 ?\n" 
  "      values.data[valueStartOffset + elem1 * valueSliceStride] : ({{V}}) 0;\n" 
  "\n" 
  "    sharedKeys[elem1] = k1;\n" 
  "    sharedValues[elem1] = v1;\n" 
  "    sharedValid[elem1] = valid1;\n" 
  "\n" 
  "    bool valid2 = (elem2 < keySliceSize);\n" 
  "    {{K}} k2 = valid2 ?\n" 
  "      keys.data[keyStartOffset + elem2 * keySliceStride] : ({{K}}) 0;\n" 
  "    {{V}} v2 = valid2 ?\n" 
  "      values.data[valueStartOffset + elem2 * valueSliceStride] : ({{V}}) 0;\n" 
  "\n" 
  "    sharedKeys[elem2] = k2;\n" 
  "    sharedValues[elem2] = v2;\n" 
  "    sharedValid[elem2] = valid2;\n" 
  "\n" 
  "    // Sort!\n" 
  "    bitonicSort<Comparator, K, V, {{IndexType}}, Power2SortSize>(\n" 
  "      sharedKeys, sharedValues, sharedValid, comp);\n" 
  "\n" 
  "    // elem1 values are always valid, since otherwise we would have\n" 
  "    // chosen the next smallest power-of-2 for sorting\n" 
  "    keys.data[keyStartOffset + elem1 * keySliceStride] =\n" 
  "      sharedKeys[elem1];\n" 
  "    values.data[valueStartOffset + elem1 * valueSliceStride] =\n" 
  "      sharedValues[elem1];\n" 
  "\n" 
  "    if (valid2) {\n" 
  "      // elem2 values might be out-of-range, if the data size we are\n" 
  "      // sorting is not a power-of-2\n" 
  "      keys.data[keyStartOffset + elem2 * keySliceStride] =\n" 
  "        sharedKeys[elem2];\n" 
  "      values.data[valueStartOffset + elem2 * valueSliceStride] =\n" 
  "        sharedValues[elem2];\n" 
  "    }\n" 
  "  }\n" 
  "}\n" 
  "\n" 
  "";
  // [[[end]]]
  return kernelSource;
}



